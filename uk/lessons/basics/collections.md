---
version: 1.3.0
title: Колекції
---

Списки, кортежі, ключові списки та асоціативні масиви.

{% include toc.html %}

## Списки
Списки &mdash; це звичайні колекції значень. 
Вони можуть включати різні типи та неунікальні значення.

```elixir
iex> [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
```

Списки в Elixir є однобічно зв'язними.
Це означає, що отримання довжини списку - операція, яка буде виконана за лінійний час (`O(n)`).
Із цієї причини додавати елементи в початок списку набагато швидше, ніж у його кінець.

```elixir
iex> list = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
# Додавати в початок (швидко)
iex> ["π" | list]
["π", 3.14, :pie, "Apple"]
# Додавати в кінець (повільно)
iex> list ++ ["Cherry"]
[3.14, :pie, "Apple", "Cherry"]
```

### Об'єднання списків

Для об'єднання списків використовується оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

Невелика замітка щодо формату імен (`++/2`), який використовувався вище: в
Elixir (та й в Erlang, на основі якого створений Elixir) імена функцій та
операторів складаються з двох частин: безпосередньо імені (в цьому випадку `++`)
та _арності_. Арність &mdash; одне з ключових понять Elixir та Erlang. Це
кількість аргументів, які приймає функція (у цьому випадку два). Арність та ім'я
з'єднуються за допомогою слешa. Пізніше ми розберемо це детальніше.

### Віднімання списків

Оператор `--/2` дає можливість віднімати списки. Не буде помилкою віднімання неіснуючого елемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

Зверніть увагу на повторні значення. 
З лівого списку видаляється тільки перше входження кожного елемента правого списку:

```elixir
iex> [1,2,2,3,2,3] -- [1,2,3,2]
[2, 3]
```

**Зауваження:** Для порівняння елементів використовується [строге порівняння](../basics#Порівняння). 
Наприклад:
```elixir
iex> [2] -- [2.0]
[2]
iex> [2.0] -- [2.0]
[]
```

### Голова / Хвіст

Під час використання списків звичайною є робота з "головою" та "хвостом" списку.
"Головою" є перший елемент, а "хвостом" &mdash; усі інші елементи.
Для роботи з ними Elixir надає два оператори &mdash; `hd` та `tl`:

```elixir
iex> hd [3.14, :pie, "Apple"]
3.14
iex> tl [3.14, :pie, "Apple"]
[:pie, "Apple"]
```

Того ж результату можливо досягти, використовуючи [зіставлення зі зразком](../pattern-matching/) 
aбо оператор cons &mdash; `|`. Ми будемо часто його зустрічати в наступних уроках.

```elixir
iex> [head | tail] = [3.14, :pie, "Apple"]
[3.14, :pie, "Apple"]
iex> head
3.14
iex> tail
[:pie, "Apple"]
```

## Кортежі

Кортежі схожі на списки, але зберігаються в пам'яті послідовно.
Це робить отримання їх довжини швидким, але але редагування "дорогим";
новостворений кортеж повинен бути повністю cкопійованим у нову область пам'яті.
Кортежі створюються за допомогою фігурних дужок:

```elixir
iex> {3.14, :pie, "Apple"}
{3.14, :pie, "Apple"}
```

Часто вони використовуються як механізм для отримання додаткової інформації з функцій. 
Користь цього стане більш очевидною пізніше, коли ми будемо заглиблюватися в 
[зіставлення зі зразком](../pattern-matching/):

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключові списки

Ключові списки та асоціативні масиви є асоціативнними колекціми в Elixir.
В Elixir ключові списки &mdash; це спеціальні списки з двоелементних кортежів, 
першим елементом яких є атом. По швидкості вони ідентичні спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики цієї структури даних показують її важливість:

+ Ключі є атомами.
+ Ключі є впорядкованими.
+ Ключі не повинні бути унікальними.

Тому вона часто використовується для передачі параметрів у функції.

## Асоціативні масиви

В Elixir асоціативний масив &mdash; це сховище типу ключ-значення з можливістю швидкого отримання 
інформації по ключу. На відміну від ключових списків, вони підтримують будь-який тип ключів і не є 
впорядкованими. Асоціативний масив оголошується за допомогою синтаксису `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

З версії Elixir 1.2 змінні підтримуються у якості ключів:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Якщо в цю структуру даних додається дублікат, він перепише старе значення:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Як видно з результату команди вище, існує спеціальний короткий синтаксис для асоціативних масивів, 
ключами яких є тільки атоми:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```

Також існує спеціальний синтаксис для отримання значень ключів-атомів:

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> map.hello
"world"
```

Ще одна цікава особливість асоціативних масивів &mdash; це особливий синтаксис для оновлення 
(зауваження: це створює новий асоціативний масив):

```elixir
iex> map = %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}
iex> %{map | foo: "baz"}
%{foo: "baz", hello: "world"}
```

**Зауваження**: цей синтаксис працює лише для оновлення ключа, який уже існує в асоціативному 
масиві! Якщо ключ не існує, ви отримаєте `KeyError`.

Для того, щоб створити новий ключ, використовуйте [`Map.put/3`](https://hexdocs.pm/elixir/Map.html#put/3)

```elixir
iex> map = %{hello: "world"}
%{hello: "world"}
iex> %{map | foo: "baz"}
** (KeyError) key :foo not found in: %{hello: "world"}
    (stdlib) :maps.update(:foo, "baz", %{hello: "world"})
    (stdlib) erl_eval.erl:259: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1263: :lists.foldl/3
iex> Map.put(map, :foo, "baz")
%{foo: "baz", hello: "world"}
```
